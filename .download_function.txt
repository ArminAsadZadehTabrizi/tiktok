def download_youtube_clip(category, output_path, clip_duration=4):
    """
    Download a random clip from YouTube with dynamic search fallback and multi-format retry.
    
    Args:
        category (str): Category name (CARS/COMBAT/GYM/LUXURY)
        output_path (Path): Where to save the clip
        clip_duration (int): Duration of clip to extract in seconds
    
    Returns:
        bool: True if successful, False otherwise
    """
    if not YOUTUBE_AVAILABLE:
        return False
    
    # Check if category exists
    if category not in config.YOUTUBE_SOURCES:
        print(f"    ‚úó Unknown category: {category}")
        return False
    
    # STRATEGY 1: Try configured URLs first (with health check)
    urls = config.YOUTUBE_SOURCES[category]
    valid_urls = []
    
    if urls:
        print(f"    üîç Validating {len(urls)} configured URL(s)...")
        for url in urls:
            if check_youtube_url_health(url):
                valid_urls.append(url)
                print(f"    ‚úì Valid URL")
            else:
                print(f"    ‚úó Dead/unavailable URL, skipping")
    
    # STRATEGY 2: If no valid URLs, use dynamic search
    enable_search = getattr(config, 'YOUTUBE_ENABLE_SEARCH', True)
    if not valid_urls and enable_search:
        print(f"    üîé No valid configured URLs, falling back to dynamic search...")
        valid_urls = search_youtube_videos(category, max_results=3)
        
        if not valid_urls:
            print(f"    ‚úó Dynamic search returned no results for {category}")
            return False
    
    if not valid_urls:
        print(f"    ‚úó No valid URLs available for category: {category}")
        return False
    
    # STRATEGY 3: Try multiple videos and formats with retry logic
    attempted_urls = []
    max_attempts = 3
    
    for attempt in range(min(max_attempts, len(valid_urls))):
        # Pick a random URL we haven't tried yet
        available_urls = [url for url in valid_urls if url not in attempted_urls]
        if not available_urls:
            break
        
        video_url = random.choice(available_urls)
        attempted_urls.append(video_url)
        
        # Try multiple format strategies for this video
        format_strategies = [
            ('best[height<=1080][ext=mp4]/best[ext=mp4]', 'Pre-merged stream'),
            ('bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]', 'Video+audio merge'),
            ('best[ext=mp4]/best', 'Any MP4 format'),
        ]
        
        for format_string, format_desc in format_strategies:
            try:
                print(f"    üé¨ Attempt {attempt + 1}/{max_attempts}: {format_desc}")
                
                # Get video info without downloading
                ydl_opts = {
                    'quiet': True,
                    'no_warnings': True,
                    'extract_flat': False,
                }
                
                # Add cookie file if configured
                cookie_file = getattr(config, 'YOUTUBE_COOKIE_FILE', None)
                if cookie_file:
                    ydl_opts['cookiefile'] = str(cookie_file)
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(video_url, download=False)
                    duration = info.get('duration', 0)
                    
                    if duration < 120:  # Video too short
                        print(f"    ‚úó Video too short ({duration}s), need at least 2 minutes")
                        break  # Try next URL
                    
                    # Calculate random start time (avoid first/last 60s)
                    safe_start = 60
                    safe_end = duration - 60 - clip_duration
                    
                    if safe_end <= safe_start:
                        print(f"    ‚úó Video not long enough for safe clip extraction")
                        break  # Try next URL
                    
                    start_time = random.randint(safe_start, safe_end)
                    end_time = start_time + clip_duration
                    
                    print(f"    ‚è±Ô∏è  Extracting {start_time}s-{end_time}s from {duration}s video")
                    
                    # Download only the specific segment
                    download_opts = {
                        'format': format_string,
                        'outtmpl': str(output_path),
                        'quiet': False,  # Enable output to see ffmpeg errors
                        'no_warnings': False,
                        # Precise cutting
                        'download_ranges': yt_dlp.utils.download_range_func(None, [(start_time, end_time)]),
                        'force_keyframes_at_cuts': True,
                    }
                    
                    # Add cookie file if configured
                    if cookie_file:
                        download_opts['cookiefile'] = str(cookie_file)
                    
                    with yt_dlp.YoutubeDL(download_opts) as ydl_download:
                        ydl_download.download([video_url])
                    
                    # Verify the file was created
                    if output_path.exists() and output_path.stat().st_size > 0:
                        print(f"    ‚úì YouTube clip downloaded successfully ({category}, {format_desc})")
                        return True
                    else:
                        print(f"    ‚úó Download failed - file not created")
                        continue  # Try next format
                        
            except yt_dlp.utils.DownloadError as e:
                error_msg = str(e).lower()
                
                # Check for specific error types
                if 'ffmpeg' in error_msg and 'exit' in error_msg:
                    print(f"    ‚úó FFmpeg error with {format_desc}, trying different format...")
                    time.sleep(0.5)
                    continue  # Try next format
                elif 'sign in' in error_msg or 'age' in error_msg:
                    print(f"    ‚úó Age-restricted content. Export YouTube cookies to youtube_cookies.txt")
                    break  # Try next URL (cookies won't help with format change)
                else:
                    print(f"    ‚úó Download error: {str(e)[:100]}")
                    continue  # Try next format
                    
            except Exception as e:
                print(f"    ‚úó Unexpected error: {str(e)[:100]}")
                continue  # Try next format
        
        # Add delay between video attempts
        if attempt < max_attempts - 1:
            time.sleep(1)
    
    print(f"    ‚úó All YouTube download attempts failed for {category}")
    return False
